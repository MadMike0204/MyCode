#include<stdio.h>
#include<string.h>
int main(void){
    char n1[3000],n2[3000];
    scanf("%s%s",&n1,&n2);
    int a[3000],b[3000],c[3000];
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
    int l1 = strlen(n1);
    int l2 = strlen(n2);
    int i,j;
    for(i=0,j=l1-1;i<l1;i++,j--)//j如果不减1，那么数字将错位，因为定义3000长度，编号为0~2999
    {
        a[j] = n1[i] - '0';/*0作为字符是30,因为传递给数组的是char的ascii值，所以每个char减去30
                              就能得到对应int数字*/
    }
    for(i=0,j=l2-1;i<l2;i++,j--)
    {
        b[j] = n2[i] - '0';
    }
//数字都转移完了，下面我们开始进行运算
//首先计算循环次数
//这里采用if判断
int len;
    if(l1>l2) 
        len = l1;
    else 
        len = l2;
//等于不用考虑，因为都一样，所以选择哪个无所谓
    for(i=0;i<len;i++)//同样的，数组是0~2999，i<len即为界限
    {
        c[i] = a[i] + b[i];
    }
//进行加法的时候可以先不用担心进位的问题，因为int类型数组每个位置能储存大小远远超过个位的数字
//现在开始进行进位 分为两个动作 一个是后一位进位 一个是本数去十位
    for(i=0;i<len;i++)
    {
        if(c[i]>=10)
        {
            c[i+1] += 1;
            c[i] %= 10;  
        }
    }
//下面开始输出，因为一开始数组全部初始化为0 所以需要判断从第一位不是0开始输出数组
//再加上是反向定位，所以  1.从数组末尾开始判断   2.判断到数组末尾
//BUT 由于高精度数字里面可能有超级多个0 所以无法以0为标准判断数组终点，要么就把全部数组判断一遍然后记录最后一位，效率很低
//所以选择实现1进行
/*实现1:*/
    while(c[i]==0 && i>0)
    {
        i--;
    }
//所得i既是数的长度
//开始输出喽
    for(j=i;j>=0;j--)
    {
        printf("%d",c[j]);
    }


    return 0;
}